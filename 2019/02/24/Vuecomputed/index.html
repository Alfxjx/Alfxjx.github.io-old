<!DOCTYPE html>
<html lang="">
  <head><meta name="generator" content="Hexo 3.8.0">
    
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="description" content="Vue中的computed（计算属性）">




  <meta name="keywords" content="Vue,">





  <link rel="alternate" href="/default" title="Alfred's">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1">



<link rel="canonical" href="http://yoursite.com/2019/02/24/Vuecomputed/">


<meta name="description" content="computed 又称计算属性, 什么情况下会用到计算属性，我们直接上代码理解一下">
<meta name="keywords" content="Vue">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue中的computed（计算属性）">
<meta property="og:url" content="http://yoursite.com/2019/02/24/Vuecomputed/index.html">
<meta property="og:site_name" content="Alfred&#39;s">
<meta property="og:description" content="computed 又称计算属性, 什么情况下会用到计算属性，我们直接上代码理解一下">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-02-24T05:10:19.068Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Vue中的computed（计算属性）">
<meta name="twitter:description" content="computed 又称计算属性, 什么情况下会用到计算属性，我们直接上代码理解一下">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1">
<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">


  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css">




<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: true
    },
  };
</script>




  



    <title> Vue中的computed（计算属性） - Alfred's </title>
  </head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">Alfred's</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Vue中的computed（计算属性）
        
      </h1>

      <time class="post-time">
          Feb 24 2019
      </time>
    </header>



    
            <div class="post-content">
            <p>computed 又称计算属性, 什么情况下会用到计算属性，我们直接上代码理解一下</p>
<a id="more"></a>
<pre><code class="html">// 我们有一个message，结过多次逻辑处理最终显示到页面中
// 它不是一个简单的声明式逻辑，我们需要看一段时间才能理解message意图
&lt;div id=&quot;example&quot;&gt;
    {{ message.split('').reverse().join('') }}
&lt;/div&gt;
// 所以，这时候应该尝试使用computed，也就是说对于任何复杂逻辑，你都应当使用计算属性
&lt;div id=&quot;example&quot;&gt;
    {{ message }}
&lt;/div&gt;
&lt;script&gt;
    var vm = new Vue({
        el: &#39;#example&#39;,
        data(){
            return{
                message : &#39;1234&#39;
            }
        },
        computed：{
        message(){
            return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;)
            }
        }
    })
&lt;/script&gt;
</code></pre>
<h3 id="computed-vs-methods"><a href="#computed-vs-methods" class="headerlink" title="computed vs methods"></a>computed vs methods</h3><p>计算属性跟方法都能达到同样的效果，那么它们之间有什么不同呢？我们还是看一段代码理解一下</p>
<pre><code class="html">&lt;p&gt;Reversed message: &quot;{{ reversedMessage() }}&quot;&lt;/p&gt;
</code></pre>
<pre><code class="javascript">// 在组件中
methods: {
  reversedMessage: function () {
    return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;)
  }
}
</code></pre>
<p>我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是<strong>计算属性是基于它们的依赖进行缓存的</strong>。只在相关依赖发生改变时它们才会重新求值。这就意味着只要 <code>message</code> 还没有发生改变，多次访问 <code>reversedMessage</code> 计算属性会立即返回之前的计算结果，而不必再次执行函数。</p>
<p>这也同样意味着下面的计算属性将不再更新，因为 <code>Date.now()</code> 不是响应式依赖：</p>
<pre><code class="javascript">computed: {
  now() {
    return Date.now()
  }
}
</code></pre>
<h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><p><a href="https://github.com/vuejs/vue/blob/33e669b22f69a1f9c9147528360fe0bba85534f0/src/core/instance/state.js#L169" target="_blank" rel="noopener">link</a></p>
<pre><code class="javascript">function initComputed (vm: Component, computed: Object) {
  // $flow-disable-line
  //新建存储watcher对象，挂载在vm对象执行
  const watchers = vm._computedWatchers = Object.create(null)
  // computed properties are just getters during SSR
  const isSSR = isServerRendering()
  //遍历computed
  for (const key in computed) {
    const userDef = computed[key]
      // 定义一个计算属性有两种写法，一种是直接跟一个函数，
    // 另一种是添加 set 和 get 方法的对象形式，
    // 所以这里首先获取计算属性的定义 userDef，
    // 再根据 userDef 的类型获取相应的 getter 求值函数
    const getter = typeof userDef === &#39;function&#39; ? userDef : userDef.get
    if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; getter == null) {
      warn(
        `Getter is missing for computed property &quot;${key}&quot;.`,
        vm
      )
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      // 初始化watcher
      watchers[key] = new Watcher(
        vm,
        getter || noop,
        noop,
        computedWatcherOptions
      )
    }

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      // 调用计算属性时会触发其Object.defineProperty的get访问器函数  
      defineComputed(vm, key, userDef)
    } else if (process.env.NODE_ENV !== &#39;production&#39;) {
      if (key in vm.$data) {
        warn(`The computed property &quot;${key}&quot; is already defined in data.`, vm)
      } else if (vm.$options.props &amp;&amp; key in vm.$options.props) {
        warn(`The computed property &quot;${key}&quot; is already defined as a prop.`, vm)
      }
    }
  }
}
</code></pre>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/Vue/">Vue</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2019/02/25/Vue中的Diff算法/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Vue中的Diff算法</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/2019/02/22/Hexo主题设置缩略图/">
        <span class="next-text nav-default">Hexo主题设置缩略图</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2018 -
    
    2019
    <span class="footer-author">Xu Jianxiang.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a> and <a class="theme-link" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
