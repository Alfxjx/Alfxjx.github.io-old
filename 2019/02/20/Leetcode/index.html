<!DOCTYPE html>
<html lang="">
  <head><meta name="generator" content="Hexo 3.8.0">
    
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

<meta name="theme-color" content="#f8f5ec">
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="长期更新的一篇文章，主要是我做的Leetcode题目的解答。">




  <meta name="keywords" content="Leetcode, Alfred's">










  <link rel="alternate" href="/default" title="Alfred's">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.10.2">



<link rel="canonical" href="http://yoursite.com/2019/02/20/Leetcode/">



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css">




  <link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css">



<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.10.2">



  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>









<script>
  window.config = {"leancloud":"app_id:87EJk4r6rO0U0Tul5uju2IPq-gzGzoHsz app_key:vhxBampeF8Xel2ETEh4RBLNa","toc":true,"fancybox":true,"pjax":true};
</script>

    <title> 长期更新Leetcode题解 - Alfred's </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Alfred's</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            标签
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            关于
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Alfred's</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              标签
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          长期更新Leetcode题解
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-02-20
        </span>
        
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-两数之和"><span class="toc-text">1. 两数之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-反转整数"><span class="toc-text">7. 反转整数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-回文数"><span class="toc-text">9. 回文数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-盛最多水的容器"><span class="toc-text">11. 盛最多水的容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-三数之和"><span class="toc-text">15. 三数之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-最接近的三数之和"><span class="toc-text">16. 最接近的三数之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-四数之和"><span class="toc-text">18. 四数之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-删除链表的倒数第N个节点"><span class="toc-text">19.删除链表的倒数第N个节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-有效的括号"><span class="toc-text">20. 有效的括号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-合并两个链表"><span class="toc-text">21.合并两个链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-删除排序数组中的重复项"><span class="toc-text">26. 删除排序数组中的重复项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-移除元素"><span class="toc-text">27. 移除元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-实现strStr"><span class="toc-text">28. 实现strStr()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-搜索插入位置"><span class="toc-text">35. 搜索插入位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36-有效的数独"><span class="toc-text">36. 有效的数独</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37-解数独"><span class="toc-text">37. 解数独</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56-合并区间"><span class="toc-text">56.合并区间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#58-最后一个单词的长度"><span class="toc-text">58. 最后一个单词的长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#61-旋转链表"><span class="toc-text">61. 旋转链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64-最小路径和"><span class="toc-text">64. 最小路径和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#66-加一"><span class="toc-text">66. 加一</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#80-删除排序数组中的重复项-II"><span class="toc-text">80.删除排序数组中的重复项 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#88-合并两个有序数组"><span class="toc-text">88.合并两个有序数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#92-反转m到n处的链表"><span class="toc-text">92. 反转m到n处的链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#104-二叉树的最大深度"><span class="toc-text">104. 二叉树的最大深度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#110-平衡二叉树"><span class="toc-text">110. 平衡二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#121-买卖股票的最佳时机"><span class="toc-text">121.买卖股票的最佳时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#125-验证回文串"><span class="toc-text">125. 验证回文串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#141-环形链表"><span class="toc-text">141.环形链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#142-寻找链表中环的入口"><span class="toc-text">142. 寻找链表中环的入口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#160-合并链表"><span class="toc-text">160. 合并链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#203-移除链表元素"><span class="toc-text">203. 移除链表元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#206-反转链表"><span class="toc-text">206. 反转链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#234-回文链表"><span class="toc-text">234. 回文链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#237-删除链表中的节点"><span class="toc-text">237. 删除链表中的节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#347-前K个高频元素"><span class="toc-text">347. 前K个高频元素#*</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#442-数组中重复的数据"><span class="toc-text">442.数组中重复的数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#717-1比特与2比特字符"><span class="toc-text">717. 1比特与2比特字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#905-按奇偶排序数组"><span class="toc-text">905. 按奇偶排序数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#914-卡牌分组"><span class="toc-text">914. 卡牌分组</span></a></li></ol>
    </div>
  </div>



    <div class="post-content">
      
        <h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h2><p>给定一个整数数组和一个目标值，找出数组中和为目标值的<strong>两个</strong>数。</p>
<p>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</p>
<p><strong>示例:</strong></p>
<pre><code>给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
</code></pre><pre><code class="Java">class Solution {
    public int[] twoSum(int[] nums, int target) {
    for(int i=0;i&lt;nums.length;i++){
        int s = target - nums[i];
        for(int j = i+1;j&lt;nums.length;j++){
            if(s == nums[j]){
                return new int[] {i,j};
            }
        }
    } 
    throw new IllegalArgumentException(&quot;No two sum solution&quot;);
    //没这句抛出异常会报错
}

}
</code></pre>
<pre><code class="python">class Solution:
    def twoSum(self, nums, target):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        &quot;&quot;&quot;
        for i in range(0,len(nums)):
            n = target-nums[i]
            for j  in range(i+1,len(nums)):
                if n == nums[j]:
                    return [i,j]
</code></pre>
<h2 id="7-反转整数"><a href="#7-反转整数" class="headerlink" title="7. 反转整数"></a>7. 反转整数</h2><p><strong>主要考虑32位可能会出现的溢出问题</strong></p>
<p>给定一个 32 位有符号整数，将整数中的数字进行反转。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: 123
输出: 321
</code></pre><p> <strong>示例 2:</strong></p>
<pre><code>输入: -123
输出: -321
</code></pre><p><strong>示例 3:</strong></p>
<pre><code>输入: 120
输出: 21
</code></pre><p><strong>注意:</strong></p>
<p>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1]。根据这个假设，如果反转后的整数溢出，则返回 0。</p>
<pre><code class="java">class Solution {
    public int reverse(int x) {
    int rev = 0;
        while (x != 0) {
            int pop = x % 10;
            x /= 10;
            if (rev &gt; Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE / 10 &amp;&amp; pop &gt; 7)) return 0;
            if (rev &lt; Integer.MIN_VALUE/10 || (rev == Integer.MIN_VALUE / 10 &amp;&amp; pop &lt; -8)) return 0;
            rev = rev * 10 + pop;
        }
        return rev;    
    }
}
</code></pre>
<pre><code class="python">class Solution:
    def reverse(self, x):
        &quot;&quot;&quot;
        :type x: int
        :rtype: int
        &quot;&quot;&quot;
        flag = 1
        out=0
        if x&lt;0:
            x = abs(x)
            flag = -1
        while(x!=0):
            pop = x%10
            out = out*10+pop
            x=x//10

        if (-2**31)&lt;out&lt; (2**31-1):
            return out*flag
        else:
            return 0
</code></pre>
<h2 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9. 回文数"></a>9. 回文数</h2><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: 121
输出: true
</code></pre><p><strong>示例 2:</strong></p>
<pre><code>输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
</code></pre><p><strong>示例 3:</strong></p>
<pre><code>输入: 10
输出: false
解释: 从右向左读, 为 01 。因此它不是一个回文数。
</code></pre><pre><code class="java">class Solution {
    public boolean isPalindrome(int x) {
        int temp = x;
        int out = 0;
        if(x&lt;0){
            return false;
        }else if(x==0){
            return true;
        }else{
            while(x!=0){
                out = out*10+x%10;
                x/=10;
            }
            if(out==temp){
                return true;
            }else{
                return false;
            }
        }
    }
}
</code></pre>
<h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a>11. 盛最多水的容器</h2><p>给定 <em>n</em> 个非负整数 <em>a</em>1，<em>a</em>2，…，<em>a</em>n，每个数代表坐标中的一个点 (<em>i</em>, <em>ai</em>) 。在坐标内画 <em>n</em> 条垂直线，垂直线 <em>i</em> 的两个端点分别为 (<em>i</em>, <em>ai</em>) 和 (<em>i</em>, 0)。找出其中的两条线，使得它们与 <em>x</em> 轴共同构成的容器可以容纳最多的水。</p>
<p><strong>说明：</strong>你不能倾斜容器，且 <em>n</em> 的值至少为 2。</p>
<p><strong>示例:</strong></p>
<pre><code>输入: [1,8,6,2,5,4,8,3,7]
输出: 49
</code></pre><pre><code class="java">class Solution {
    public int maxArea(int[] height) {
        int tmp =0;
        int s =0;
        for(int i=0;i&lt;height.length-1;i++){
            for(int j=i;j&lt;height.length;j++){
                int h=0;
                if(height[i]&gt;height[j]){
                    h = height[j];
                }else{
                    h=height[i];
                }
                tmp = (j-i)*h;
                if(tmp&gt;s){
                    s = tmp;
                }
            }
        }
        return s;
    }
}
</code></pre>
<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h2><p>给定一个包含 <em>n</em> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，</em>使得 <em>a + b + c =</em> 0 ？找出所有满足条件且不重复的三元组。</p>
<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>
<pre><code>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
</code></pre><p><strong>解法：</strong> 也是使用双pointer的方法， 主要是针对输出结构的不同，采取了一些操作。</p>
<pre><code class="java">class Solution {
    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {
        HashSet&lt;List&lt;Integer&gt;&gt; set = new HashSet&lt;&gt;();
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        int target = 0;
        if(nums.length==3){
            if(nums[0]+nums[1]+nums[2]==0){
                List&lt;Integer&gt; tmp= new ArrayList();
                tmp.add(nums[0]);
                tmp.add(nums[1]);
                tmp.add(nums[2]);
                res.add(tmp);
                return res;
            }
            //否则返回的就是空值
            return res;
        }
        Arrays.sort(nums);
        for(int i=0;i&lt;nums.length-2;i++){
            int left = i+1;
            int right = nums.length-1;
            while(left&lt;right){
                int tmpsum = nums[i]+nums[left]+nums[right];
                if(tmpsum == target){
                    List&lt;Integer&gt; tmp= new ArrayList();
                    tmp.add(nums[i]);
                    tmp.add(nums[left]);
                    tmp.add(nums[right]);
                    set.add(tmp);
                }
                if(tmpsum&lt;target){
                    left++;
                }else{
                    right--;
                }
            }
        }
        for(List&lt;Integer&gt; t: set){
            res.add(t);
        }
        return res;
    }
}
</code></pre>
<h2 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a>16. 最接近的三数之和</h2><p>给定一个包括 <em>n</em> 个整数的数组 <code>nums</code> 和 一个目标值 <code>target</code>。找出 <code>nums</code> 中的三个整数，使得它们的和与 <code>target</code> 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
<pre><code>例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.

与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).
</code></pre><p><strong>solution:</strong> 两层循环嵌套，对于某一个选定的数，左右夹击，得到一个序列的三数和，然后比较这些值与目标的大小。</p>
<pre><code class="java">class Solution {
    public int threeSumClosest(int[] nums, int target) {
        if(nums.length==3){
            return nums[0]+nums[1]+nums[2];
        }
        Arrays.sort(nums);
        int res = 0;
        int cha = Integer.MAX_VALUE;
        int tmpcha = 0;
        for(int i=0;i&lt;nums.length-2;i++){
            int left = i+1;
            int right = nums.length-1;
            while(left&lt;right){
                int tmpsum = nums[i]+nums[left]+nums[right];
                tmpcha = Math.abs(tmpsum-target);
                if(tmpcha&lt;cha){
                    cha = tmpcha;
                    res = tmpsum;
                }
                if(tmpsum==target){
                    return target;
                }
                if(tmpsum&lt;target){
                    left++;
                }else{
                    right--;
                }
            }
        }
        return res;
    }
}
</code></pre>
<h2 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a>18. 四数之和</h2><p>给定一个包含 <em>n</em> 个整数的数组 <code>nums</code> 和一个目标值 <code>target</code>，判断 <code>nums</code> 中是否存在四个元素 <em>a，**b，c</em> 和 <em>d</em> ，使得 <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em> 的值与 <code>target</code> 相等？找出所有满足条件且不重复的四元组。</p>
<p><strong>注意：</strong></p>
<p>答案中不可以包含重复的四元组。</p>
<p><strong>示例：</strong></p>
<pre><code>给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。

满足要求的四元组集合为：
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]
</code></pre><p><strong>解法：</strong> 只要确定了第一个数字，后面就是三个数字之和的题目了，所以以第一个数字为指针遍历数组，这样就实现了四数和。</p>
<pre><code class="java">class Solution {
    public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) {
        HashSet&lt;List&lt;Integer&gt;&gt; set = new HashSet&lt;&gt;();
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        if(nums.length==4){
            if(nums[0]+nums[1]+nums[2]+nums[3]== target){
                List&lt;Integer&gt; tmp= new ArrayList();
                tmp.add(nums[0]);
                tmp.add(nums[1]);
                tmp.add(nums[2]);
                tmp.add(nums[3]);
                res.add(tmp);
                return res;
            }
            //否则返回的就是空值
            return res;
        }
        Arrays.sort(nums);
        for(int begin=0;begin&lt;nums.length-3;begin++){    
            for(int end=nums.length-1;end-begin&gt;2;end--){
                int left = begin+1;
                int right = end-1;
                while(left&lt;right){
                    int tmpsum = nums[begin]+nums[end]+nums[left]+nums[right];
                    if(tmpsum == target){
                        List&lt;Integer&gt; tmp= new ArrayList();
                        tmp.add(nums[begin]);
                        tmp.add(nums[end]);
                        tmp.add(nums[left]);
                        tmp.add(nums[right]);
                        set.add(tmp);
                        left++;
                    }
                    if(tmpsum&lt;target){
                        left++;
                    }else{
                        right--;
                    }
                }
            }
        }
        for(List&lt;Integer&gt; t: set){
            res.add(t);
        }
        return res;
    }
}
</code></pre>
<h2 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19.删除链表的倒数第N个节点"></a>19.删除链表的倒数第N个节点</h2><p>目标是删除链表的倒数第N个节点。<br>我的思路是数出链表的长度，然后即可知道删除的节点的位置，再对链表进行遍历，即可删除节点。<br><strong>有待完善程序</strong></p>
<pre><code class="java">// me wrong
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode fir = head;
        int cnt =0;
        while(head!=null){
            head = head.next;
            cnt++;
        }
        int p = cnt+1-n;
        head = fir;
        for(int i = 0; i&lt;p; i++){
            head = head.next;
        }
        head.val = head.next.val;
        head.next = head.next.next;
        return head;
    }
}
</code></pre>
<p>答案的方法就是：</p>
<p>假如是删除最后 一个节点，也就是n=1时，删除最后一个节点。</p>
<p>当N不是1时，采用快慢两个指针，快指针先走N-1步，然后两个指针一起行动，当快指针到达链表的末尾时，慢指针指到需要删除的节点。采用删除节点的方法（与上面的情况一不一样。）</p>
<pre><code class="java">class Solution{
    public ListNode removeNthFromEnd(ListNode head, int n){
        int length =0 ;
        if(n==1){
            if(head.next==null){
            return null;
            }
            ListNode temp = head.next;
            ListNode pre = head;
            while(temp.next!=null){
                temp = temp.next;
                pre = pre.next;
            }
            pre.next = null;
            return head;
        }
        n = n-1;
        ListNode fast = head;
        ListNode slow = head;
        for(int i=0; i&lt;n;i++){
            fast = fast.next;
        }
        while(fast.next!=null){
            fast = fast.next;
            slow = slow.next;
        }
        slow.val = slow.next.val;
        slow.next = slow.next.next;
        return head;
    }
}
</code></pre>
<p>一种简洁的做法：</p>
<pre><code class="Java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;

        ListNode fast = head, slow = dummy;
        for (int i = 0; i &lt; n; i++) {
          fast = fast.next;
        }

        while (fast != null) {
          fast = fast.next;
          slow = slow.next;
        }
        slow.next = slow.next.next;
        return dummy.next;
    }
}
</code></pre>
<h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h2><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;{&#39;</code>，<code>&#39;}&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
</ol>
<p>注意空字符串可被认为是有效字符串。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: &quot;()&quot;
输出: true
</code></pre><p><strong>示例 2:</strong></p>
<pre><code>输入: &quot;()[]{}&quot;
输出: true
</code></pre><p><strong>示例 3:</strong></p>
<pre><code>输入: &quot;(]&quot;
输出: false
</code></pre><p><strong>示例 4:</strong></p>
<pre><code>输入: &quot;([)]&quot;
输出: false
</code></pre><p><strong>示例 5:</strong></p>
<pre><code>输入: &quot;{[]}&quot;
输出: true
</code></pre><p><a href="https://leetcode-cn.com/problems/valid-parentheses/solution/" target="_blank" rel="noopener">算法</a></p>
<pre><code class="java">class Solution {

    private HashMap&lt;Character, Character&gt; mappings;

    public Solution(){
        this.mappings = new HashMap&lt;Character, Character&gt;();
        this.mappings.put(&#39;)&#39;, &#39;(&#39;);
        this.mappings.put(&#39;]&#39;, &#39;[&#39;);
        this.mappings.put(&#39;}&#39;, &#39;{&#39;);
    }

    public boolean isValid(String s) {
        Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();
        for(int i = 0; i&lt;s.length(); i++){
            char c = s.charAt(i);
            if(this.mappings.containsKey(c)){
                // Get the top element of the stack. 
                //If the stack is empty, set a dummy value of &#39;#&#39;
                char topElement = stack.empty()? &#39;#&#39;:stack.pop();
                if(topElement != this.mappings.get(c)){
                    return false;
                }
            }else{
                stack.push(c);
            }
        }
        return stack.isEmpty();

    }
}
</code></pre>
<pre><code class="python">class Solution(object):
    def isValid(self, s):
        stack = []
        mapping = {&quot;)&quot;: &quot;(&quot;, &quot;}&quot;: &quot;{&quot;, &quot;]&quot;: &quot;[&quot;}
        for char in s:
            if char in mapping:
                top_element = stack.pop() if stack else &#39;#&#39;
                if mapping[char] != top_element:
                    return False
            else:
                stack.append(char)
        return not stack

</code></pre>
<h2 id="21-合并两个链表"><a href="#21-合并两个链表" class="headerlink" title="21.合并两个链表"></a>21.合并两个链表</h2><p>Merge two sorted lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.<br>input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>output:1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
<p><strong>不明白的地方</strong>就是为什么要设置一个res &amp; temp，只设置一个不知道可不可以，别的就是一个对于链表的操作。</p>
<pre><code class="java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    ListNode temp = new ListNode(-1)；
    ListNode res = temp;
    while(l1!=null&amp;&amp;l2!=null){
        if(l1.val&lt;l2.val){
            temp.next = l1;
            l1 = l1.next;
            temp = temp.next;
        }else{
            temp.next = l2;
            l2 = l2.next;
            temp = temp.next
        }
    }
    if(l1 == null){
        temp.next = l2;
    }
    if(l2 == null){
        temp.next = l1;
    }
    return res.next;    
    }
}
</code></pre>
<h2 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26. 删除排序数组中的重复项"></a>26. 删除排序数组中的重复项</h2><p>给定一个排序数组，你需要在<strong>原地</strong>删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>示例 1:</strong></p>
<pre><code>给定数组 nums = [1,1,2], 

函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 

你不需要考虑数组中超出新长度后面的元素。
</code></pre><p><strong>示例 2:</strong></p>
<pre><code>给定 nums = [0,0,1,1,1,2,2,3,3,4],

函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

你不需要考虑数组中超出新长度后面的元素。
</code></pre><p><strong>说明:</strong></p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以<strong>“引用”</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<pre><code>// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i &lt; len; i++) {
    print(nums[i]);
}
</code></pre><pre><code class="java">//就是用双指针的思想，first和last一前一后，fisrt不动，last只要和fisrt所在的位置的值相同，那么last就+1，也就是last往后移动，直到last的值与first的值不相同，那么这个时候，first需要向前移动一个位置（first++）,然后把last的值赋值到fisrt的位置；
//这样fisrt就又变成了新的值，last需要重复上述过程，直到找到不同于first的值；
//上述过程注意记录last赋值给first值的过程，赋值了几次就是有几个不同的数，也就是要返回的数组的长度
class Solution {
    public int removeDuplicates(int[] nums) {
        if(nums.length==0){
            return 0;
        }
        if(nums.length==1){
            return 1;
        }
        int first = 0;
        int last = 1;
        int cnt=1;
        while(last&lt;nums.length){
            if(nums[last]==nums[first]){
                last++;
            }else{
                cnt++;
                first++;
                nums[first]=nums[last];
                //这里感觉不需要++了
                //last++;
            }
        }
        return cnt;
    }
}
</code></pre>
<h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h2><p>给定一个数组 <em>nums</em> 和一个值 <em>val</em>，你需要<strong>原地</strong>移除所有数值等于 <em>val</em> 的元素，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p><strong>示例 1:</strong></p>
<pre><code>给定 nums = [3,2,2,3], val = 3,

函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。

你不需要考虑数组中超出新长度后面的元素。
</code></pre><p><strong>示例 2:</strong></p>
<pre><code>给定 nums = [0,1,2,2,3,0,4,2], val = 2,

函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。

注意这五个元素可为任意顺序。

你不需要考虑数组中超出新长度后面的元素。
</code></pre><p><strong>说明:</strong></p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以<strong>“引用”</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<pre><code>// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
int len = removeElement(nums, val);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i &lt; len; i++) {
    print(nums[i]);
}
</code></pre><pre><code class="java">class Solution {
    public int removeElement(int[] nums, int val) {
        int start = 0;
        int end = nums.length-1;
        int cnt = 0;
        while(start&lt;=end){
            while(start&lt;nums.length&amp;&amp;nums[start]!=val){
                start++;
            }
            while(end&gt;=0&amp;&amp; nums[end]==val){
                end--;
                cnt++;
            }
            if(start&gt;end||start&gt;nums.length|end&lt;0){
                break;
            }
            int temp = nums[start];
            nums[start] = nums[end];
            nums[end] = temp;
        }
        return nums.length-cnt;
    }
}
</code></pre>
<h2 id="28-实现strStr"><a href="#28-实现strStr" class="headerlink" title="28. 实现strStr()"></a>28. 实现strStr()</h2><p>实现 <a href="https://baike.baidu.com/item/strstr/811469" target="_blank" rel="noopener">strStr()</a> 函数。</p>
<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  <strong>-1</strong>。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;
输出: 2
</code></pre><p><strong>示例 2:</strong></p>
<pre><code>输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;
输出: -1
</code></pre><p><strong>说明:</strong></p>
<p>当 <code>needle</code> 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p>
<p>对于本题而言，当 <code>needle</code> 是空字符串时我们应当返回 0 。这与C语言的 <a href="https://baike.baidu.com/item/strstr/811469" target="_blank" rel="noopener">strstr()</a> 以及 Java的 <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String" target="_blank" rel="noopener">indexOf()</a>) 定义相符。</p>
<pre><code class="java">class Solution {
    public int strStr(String haystack, String needle) {
        if(needle.length()==0){
            return 0;
        }
        //转化成字符串数组
        char[] charArrayhaystack = haystack.toCharArray();
        char[] charArrayneedle = needle.toCharArray();
        for(int i=0;i&lt;charArrayhaystack.length;i++){
            if(charArrayhaystack[i]==charArrayneedle[0]){
                int j=i+1;
                int k=1;
                for(k=1; k&lt;charArrayneedle.length&amp;&amp;j&lt;charArrayhaystack.length;k++){
                    if(charArrayhaystack[j]==charArrayneedle[k]){
                        j++;
                    }else{
                        break;
                    }
                }
                //needle字符串都遍历完了，k已经到了字符串的末尾的位置了，说明每个字符都相等，那么就返回haystack字符串开始的位置i;
                if(k==charArrayneedle.length){
                    return i;
                }
            }
        }
        return -1;
    }
}
</code></pre>
<h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a>35. 搜索插入位置</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: [1,3,5,6], 5
输出: 2
</code></pre><p><strong>示例 2:</strong></p>
<pre><code>输入: [1,3,5,6], 2
输出: 1
</code></pre><p><strong>示例 3:</strong></p>
<pre><code>输入: [1,3,5,6], 7
输出: 4
</code></pre><p><strong>示例 4:</strong></p>
<pre><code>输入: [1,3,5,6], 0
输出: 0
</code></pre><pre><code class="java">//有点问题
class Solution {
    public int searchInsert(int[] nums, int target) {
        int [] temp = new int [nums.length+1];
        for(int i=0;i&lt;nums.length;i++){
            temp[i] = nums[i];
        }
        temp[nums.length] = target;
        Arrays.sort(temp);
        int res = 0;
        int i = 0;
        while(temp[i] != target){
            i++;
        }
        res = temp[i];
        return res;
    }
}
//对的版本
class Solution {
    public int searchInsert(int[] nums, int target) {
        int i;
        if(nums.length==0){
            return 0;
        }
        for(i=0;i&lt;nums.length;i++){
            if(target&lt;=nums[i]){
                break;
            }
        }
        return i;
    }
}
</code></pre>
<h2 id="36-有效的数独"><a href="#36-有效的数独" class="headerlink" title="36. 有效的数独"></a>36. 有效的数独</h2><p>判断一个 9x9 的数独是否有效。只需要<strong>根据以下规则</strong>，验证已经填入的数字是否有效即可。</p>
<ol>
<li>数字 <code>1-9</code> 在每一行只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一列只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。</li>
</ol>
<p><strong>示例 1:</strong></p>
<pre><code>输入:
[
  [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],
  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],
  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],
  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],
  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],
  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],
  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],
  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],
  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]
]
输出: true
</code></pre><p><strong>示例 2:</strong></p>
<pre><code>输入:
[
  [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],
  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],
  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],
  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],
  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],
  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],
  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],
  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],
  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]
]
输出: false
解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。
     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
</code></pre><p><strong>说明:</strong></p>
<ul>
<li>一个有效的数独（部分已被填充）不一定是可解的。</li>
<li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li>
<li>给定数独序列只包含数字 <code>1-9</code> 和字符 <code>&#39;.&#39;</code> 。</li>
<li>给定数独永远是 <code>9x9</code> 形式的。</li>
</ul>
<pre><code class="java">class Solution {
public boolean isValidSudoku(char[][] board) {
        for (int i = 0; i &lt; 9; i++) {
            HashSet&lt;Character&gt; row = new HashSet&lt;&gt;();
            HashSet&lt;Character&gt; column = new HashSet&lt;&gt;();
            HashSet&lt;Character&gt; cube = new HashSet&lt;&gt;();
            for (int j = 0; j &lt; 9; j++) {
                // 检查第i行，在横坐标位置
                if (board[i][j] != &#39;.&#39; &amp;&amp; !row.add(board[i][j]))
                    return false;
                // 检查第i列，在纵坐标位置
                if (board[j][i] != &#39;.&#39; &amp;&amp; !column.add(board[j][i]))
                    return false;
                // 行号+偏移量
                int RowIndex = 3 * (i / 3) + j / 3;
                // 列号+偏移量
                int ColIndex = 3 * (i % 3) + j % 3;
                //每个小九宫格，总共9个
                if (board[RowIndex][ColIndex] != &#39;.&#39; 
                        &amp;&amp; !cube.add(board[RowIndex][ColIndex]))
                    return false;
            }
        }
        return true;
    }
}
</code></pre>
<h2 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37. 解数独"></a>37. 解数独</h2><p>编写一个程序，通过已填充的空格来解决数独问题。</p>
<p>一个数独的解法需<strong>遵循如下规则</strong>：</p>
<ol>
<li>数字 <code>1-9</code> 在每一行只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一列只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。</li>
</ol>
<p>空白格用 <code>&#39;.&#39;</code> 表示。</p>
<p><a href="https://blog.csdn.net/mine_song/article/details/70209738" target="_blank" rel="noopener"><strong>解法：</strong></a>用回溯的方法，每次往一个格子里面填数字，若是出现不符合条件的情况，就退回修改之前的状态。</p>
<pre><code class="java">class Solution {
    public void solveSudoku(char[][] board) {
        if(board==null||board.length==0){
            return;
        }
        dfs(board);    
    }
    private boolean dfs(char[][] board){
        for(int i =0; i&lt;board.length;i++){
            for(int j=0;j&lt;board[0].length;j++){
                if(board[i][j]==&#39;.&#39;){
                    for(char num =&#39;1&#39;; num&lt;=&#39;9&#39;;num++){
                        if(isValid(board,i,j,num)){
                            board[i][j] = num;
                            if(dfs(board)){
                                return true;
                            }else{
                              board[i][j] = &#39;.&#39;;  
                            }
                        }
                    }
                    return false;
                }
            }
        }
        return true;
    }
    private boolean isValid(char[][] board, int i, int j, char c){
        for(int row=0;row&lt;9;row++){
            if(board[row][j]==c){
                return false;
            }
        }
        for(int col=0;col&lt;9;col++){
            if(board[i][col]==c){
                return false;
            }
        }
        int rs = i/3*3;
        int cs = j/3*3;
        for(int row = rs;row&lt;rs+3;row++){
            for(int col = cs; col&lt;cs+3;col++){
               if(board[row][col]==c){
                   return false;
               } 
            }
        }
        return true;
    }

}
</code></pre>
<h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56.合并区间"></a>56.合并区间</h2><p>给出一个区间的集合，请合并所有重叠的区间。</p>
<p>示例 1:</p>
<p>输入: [[1,3],[2,6],[8,10],[15,18]]</p>
<p>输出: [[1,6],[8,10],[15,18]]</p>
<p>解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</p>
<p>示例 2:</p>
<p>输入: [[1,4],[4,5]]</p>
<p>输出: [[1,5]]</p>
<p>解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</p>
<pre><code class="java">
</code></pre>
<h2 id="58-最后一个单词的长度"><a href="#58-最后一个单词的长度" class="headerlink" title="58. 最后一个单词的长度"></a>58. 最后一个单词的长度</h2><p>给定一个仅包含大小写字母和空格 <code>&#39; &#39;</code> 的字符串，返回其最后一个单词的长度。</p>
<p>如果不存在最后一个单词，请返回 0 。</p>
<p><strong>说明：</strong>一个单词是指由字母组成，但不包含任何空格的字符串。</p>
<p><strong>示例:</strong></p>
<pre><code>输入: &quot;Hello World&quot;
输出: 5
</code></pre><pre><code class="java">class Solution {
    public int lengthOfLastWord(String s) {
        String[] list = s.split(&quot; &quot;);
        if(list.length==0){
            return 0;
        }else{
            return list[list.length-1].length();
        }
    }
}
</code></pre>
<h2 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61. 旋转链表"></a>61. 旋转链表</h2><p>给定一个链表，旋转链表，将链表每个节点向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2
输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL
解释:
向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL
向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL
</code></pre><p><strong>示例 2:</strong></p>
<pre><code>输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4
输出: 2-&gt;0-&gt;1-&gt;NULL
解释:
向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL
向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL
向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL
向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL
</code></pre><pre><code class="java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode rotateRight(ListNode head, int k) {
        if(head==null||head.next==null){
            return head;
        }
        int len = 0;
        ListNode temp = head;
        while(temp!=null){ 
            len++;
            temp = temp.next;
        }
        //确定套圈之外，链表实际需要移动的距离。
        k=k%len;
        if(k==0){
            return head;
        }
        //旋转链表的方法
        ListNode fast = head;
        ListNode slow = head;
        for(int i=0;i&lt;k;i++){
            fast = fast.next;
        }
        while(fast.next!=null){
            fast=fast.next;
            slow=slow.next;
        }
        ListNode res = slow.next;
        fast.next = head;
        slow.next = null;
        return res;
    }
}
</code></pre>
<h2 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a>64. 最小路径和</h2><p>给定一个包含非负整数的 <em>m</em> x <em>n</em> 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p><strong>说明：</strong>每次只能向下或者向右移动一步。</p>
<p><strong>示例:</strong></p>
<pre><code>输入:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。
</code></pre><p><strong>解决方法： </strong> 是不是类似于广度优先搜素（BFS）？</p>
<pre><code class="java">class Solution {
    public int minPathSum(int[][] grid) {
        int rows = grid.length;
        int cols = 0;
        if(rows!=0){
            cols = grid[0].length;
        }
        //新建一个路径长度数组，大小和原数组一致
        int[][] equation = new int[rows][cols];
        //遍历数组
        for(int i=0;i&lt;rows;i++){
            for(int j=0;j&lt;cols;j++){
                //初始条件
                if(i==0&amp;&amp;j==0){
                    equation[i][j]=grid[0][0];
                }else if(i==0){
                    equation[i][j]=equation[i][j-1]+grid[i][j];
                }else if(j==0){
                    equation[i][j]=equation[i-1][j]+grid[i][j];
                //上面两行表示的事在边界的情况
                }else{
                    //两条路比较，选较近的
                    if(equation[i][j-1]&lt;equation[i-1][j]){
                        equation[i][j]=equation[i][j-1]+grid[i][j];
                    }else{
                        equation[i][j]=equation[i-1][j]+grid[i][j];
                    }
                }
            }
        }
        return equation[rows-1][cols-1];
    }
}
</code></pre>
<h2 id="66-加一"><a href="#66-加一" class="headerlink" title="66. 加一"></a>66. 加一</h2><p>给定一个由<strong>整数</strong>组成的<strong>非空</strong>数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: [1,2,3]
输出: [1,2,4]
解释: 输入数组表示数字 123。
</code></pre><p><strong>示例 2:</strong></p>
<pre><code>输入: [4,3,2,1]
输出: [4,3,2,2]
解释: 输入数组表示数字 4321。
</code></pre><pre><code class="java">//需要考虑的就是数组中出现9的问题,需要进位,以及999时需要让数组长度+1
class Solution {
    public int[] plusOne(int[] digits) {
        boolean flag = true;
        for(int i=0;i&lt;digits.length;i++){
            if(digits[i]!=9){
                flag = false;
                break;
            }
        }
        if(flag){
            int[] res = new int [digits.length+1];
            res[0]=1;
            return res;
        }else{
            for(int i =digits.length-1; i&gt;=0;i--){
                if(digits[i]!= 9){
                    digits[i]+=1;
                    break;
                }else{
                    digits[i]=0;
                }
            }
        }
        return digits;
    }
}
</code></pre>
<h2 id="80-删除排序数组中的重复项-II"><a href="#80-删除排序数组中的重复项-II" class="headerlink" title="80.删除排序数组中的重复项 II"></a>80.删除排序数组中的重复项 II</h2><p>给定一个排序数组，你需要在<strong>原地</strong>删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>示例 1:</strong></p>
<pre><code>给定 nums = [1,1,1,2,2,3],

函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。

你不需要考虑数组中超出新长度后面的元素。
</code></pre><p><strong>示例 2:</strong></p>
<pre><code>给定 nums = [0,0,1,1,1,1,2,3,3],

函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。

你不需要考虑数组中超出新长度后面的元素。
</code></pre><p><strong>说明:</strong></p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以<strong>“引用”</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<pre><code>// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i &lt; len; i++) {
    print(nums[i]);
}
</code></pre><pre><code class="java">class Solution {
    public int removeDuplicates(int[] nums) {
        int cnt= 0;
        if(nums.length==0){
            return 0;
        }
        if(nums.length==1){
            return 1;
        }
        int i=0;
        int j=i;
        int tmp=0;
        while(i&lt;nums.length){
            if(j&lt;nums.length&amp;&amp;nums[i]==nums[j]){
                j++;
                tmp++;
            }else{
                // star
                if(tmp&gt;=2){
                    cnt+=2;
                    nums[i+1]=nums[i];
                    i+=2;
                }else{
                    cnt++;
                    i++;
                }
            if(j&gt;=nums.length){
                break;
            }
            nums[i]=nums[j];
            tmp=0;
            }    
        }
        return cnt;
    }
}
</code></pre>
<h2 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88.合并两个有序数组"></a>88.合并两个有序数组</h2><p>给定两个有序整数数组 <em>nums1</em> 和 <em>nums2</em>，将 <em>nums2</em> 合并到 <em>nums1</em> 中<em>，</em>使得 <em>num1</em> 成为一个有序数组。</p>
<p><strong>说明:</strong></p>
<ul>
<li>初始化 <em>nums1</em> 和 <em>nums2</em> 的元素数量分别为 <em>m</em> 和 <em>n</em>。</li>
<li>你可以假设 <em>nums1</em> 有足够的空间（空间大小大于或等于 <em>m + n</em>）来保存 <em>nums2</em> 中的元素。</li>
</ul>
<p><strong>示例:</strong></p>
<pre><code>输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]
</code></pre><pre><code class="java">//思路就是一个新的数组，遍历两个数组，按顺序排放进去，当某一个数组没遍历完，也就是两个数组不一样长的时候，把没遍历完的数组接在新数组的后面，最后把新数组复制到nums1中。
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int [] res = new int[m+n];
        int i=0,j=0,k = 0;
        while(i&lt;m&amp;&amp;j&lt;n)
        {
            if(nums1[i]&lt;nums2[j]){
                res[k] = nums1[i];
                k++;
                i++;
            }else{
                res[k] = nums2[j];
                k++;
                j++;
            }
        }
        if(i!=m){
            while(i&lt;m){
                res[k] = nums1[i];
                k++;
                i++; 
            } 
        }
        if(j!=n){
            while(j&lt;n){ 
                res[k] = nums2[j];
                k++;
                j++;
            }
        }
        k = 0;
        for(i=0;i&lt;nums1.length;i++){
            nums1[i] = res[k];
            k++;
        }
    }
}
</code></pre>
<pre><code class="java">//这种不利用额外的空间
class Solution{
    public void merge(int[] nums1,int m ,int[] nums2, int n){
        int k = m+n-1;
        int i = m-1;
        int j = n-1;
        while(i&gt;=0 &amp;&amp; j&gt;=0){
            if(nums1[i]&gt;nums2[j]){
                nums1[k--] = nums1[i--];
            }else{
                nums1[k--] = nums2[j--];
            }
        }
        if(i&gt;0){
            while(i&gt;=0){
                nums1[k--] = nums1[i--];
            }
        }
        if(j&gt;0){
            while(j&gt;=0){
                nums1[k--] = nums2[j--];
            }
        }
    }
}
</code></pre>
<h2 id="92-反转m到n处的链表"><a href="#92-反转m到n处的链表" class="headerlink" title="92. 反转m到n处的链表"></a>92. 反转m到n处的链表</h2><p>反转从位置 <em>m</em> 到 <em>n</em> 的链表。请使用一趟扫描完成反转。</p>
<p><strong>说明:</strong><br>1 ≤ <em>m</em> ≤ <em>n</em> ≤ 链表长度。</p>
<p><strong>示例:</strong></p>
<pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4
输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL
</code></pre><blockquote>
<p>分两种情况讨论哈，一种是m等于1的，一种是m不等于1的</p>
</blockquote>
<blockquote>
<p>m等于1的话，简单，就是一个反转链表，如何反转见这篇文章，之前写过；m等于1的话，先反转m-n这些节点，反转完成以后，一开始的头结点就成了最后一个节点，所以反转前把这个节点保留下来，然后反转结束以后把后面的连起来就行；</p>
</blockquote>
<blockquote>
<p>m不等于1的话，说明是反转的中间部分的这些节点</p>
</blockquote>
<pre><code class="java">
</code></pre>
<h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h2><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<p><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre><p>返回它的最大深度 3 。</p>
<pre><code class="java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null){
            return 0;
        }
        int left = maxDepth(root.left);
        int right = maxDepth(root.right);
        return left&gt;right?left+1:right+1;
    }
}
</code></pre>
<h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a>110. 平衡二叉树</h2><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<blockquote>
<p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过1。</p>
</blockquote>
<p><strong>示例 1:</strong></p>
<p>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre><p>返回 <code>true</code> 。</p>
<p><strong>示例 2:</strong></p>
<p>给定二叉树 <code>[1,2,2,3,3,null,null,4,4]</code></p>
<pre><code>       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
</code></pre><p>返回 <code>false</code> 。</p>
<pre><code class="java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    private boolean flag = true;
    public boolean isBalanced(TreeNode root) {
        TreeLength(root);
        return flag;
    }
    private int TreeLength(TreeNode root){
        if( root == null){
            return 0;
        }
        int left = TreeLength(root.left);
        int right = TreeLength(root.right);
        if(left-right&gt;=2||right-left&gt;=2){
            flag = false;
        }
        return left&gt;right?(left+1):(right+1);
    }
}
</code></pre>
<h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121.买卖股票的最佳时机"></a>121.买卖股票的最佳时机</h2><p>给定一个数组，它的第 <em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
</code></pre><p><strong>示例 2:</strong></p>
<pre><code>输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
</code></pre><p>[解法]<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/()" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/()</a></p>
<pre><code class="java">class Solution {
    public int maxProfit(int[] prices) {
        int min = Integer.MAX_VALUE;
        int profit = 0;
        for(int i=0;i&lt;prices.length;i++){
            if(prices[i]&lt;min){
                min = prices[i];
            }else if(prices[i]-min&gt;profit){
                profit = prices[i]-min;
            }
        }
        return profit;
    }
}
</code></pre>
<h2 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125. 验证回文串"></a>125. 验证回文串</h2><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>
<p><strong>说明：</strong>本题中，我们将空字符串定义为有效的回文串。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: &quot;A man, a plan, a canal: Panama&quot;
输出: true
</code></pre><p><strong>示例 2:</strong></p>
<pre><code>输入: &quot;race a car&quot;
输出: false
</code></pre><pre><code class="java">// 不能处理很长的回文串，会有内存溢出的错误
class Solution {
    public boolean isPalindrome(String s) {
        s = s.toLowerCase();
        char[] charArray = s.toCharArray();
        String temp = &quot;&quot;;
        for(int i=0;i&lt;charArray.length;i++){
            if(((int)charArray[i]&gt;=48 &amp;&amp; (int)charArray[i]&lt;=57)||((int)charArray[i]&gt;=97 &amp;&amp; (int)charArray[i]&lt;=122)){
                temp+=charArray[i];
            }
        }
        char [] resArray = temp.toCharArray();
        int begin =0;
        int end = resArray.length-1;
        while(begin&lt;end){
            if(temp.charAt(begin)==temp.charAt(end)){
                begin++;
                end--;
            }else{
                return false;
            }
        }
        return true;

    }
}
</code></pre>
<h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141.环形链表"></a>141.环形链表</h2><p>给定一个链表，判断链表中是否有环。</p>
<p><strong>进阶：</strong><br>你能否不使用额外空间解决此题？</p>
<p><strong>解决方法</strong></p>
<p>设置快慢两指针，如果是环形链表，快慢指针最终会指向同一个值。</p>
<pre><code class="java">/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        if(head==null||head.next==null){
            return false;
        }
        ListNode slow = head;
        ListNode fast = head.next;
        while(slow != null&amp;&amp;fast!=null){
            if(fast==slow){
                return true;
            }
            slow = slow.next;
            if(fast.next!=null){
                fast = fast.next.next;
            }else{
                return false;
            }
        }
        return false;

    }
}
</code></pre>
<h2 id="142-寻找链表中环的入口"><a href="#142-寻找链表中环的入口" class="headerlink" title="142. 寻找链表中环的入口"></a>142. 寻找链表中环的入口</h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p>
<p><strong>说明：</strong>不允许修改给定的链表。</p>
<p><strong>进阶：</strong><br>你是否可以不用额外空间解决此题？</p>
<p><strong>think: </strong> 可以调用之前的函数，然后计算第一个出现的重复元素，就是链表的入口。</p>
<p><strong>key: </strong> 就是使用一个hash map，去遍历一遍链表，每遍历一个链表，如果不存在这个节点，那么就插入hash map，如果存在，说明这个节点已经插入了，那么这个节点就是重复的节点，为啥重复了，就是环的入口节点了。</p>
<pre><code class="java">/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        HashMap&lt;ListNode, Integer&gt; map = new HashMap&lt;&gt;();
        if(head==null||head.next==null){
            return null;
        }
        while(head!=null){
            if(map.containsKey(head)==false){
                map.put(head,1);
                head = head.next;
            }else{
                return head;
                 }  
        }
    return null; 
    }
}
</code></pre>
<h2 id="160-合并链表"><a href="#160-合并链表" class="headerlink" title="160. 合并链表"></a>160. 合并链表</h2><p>这道题是合并链表，首先获取的是两个链表的长度length A/B，然后是比较哪一个链表比较长，因为最后的输出是两个链表的最后应该是相同的，所以不一样长的部分肯定不会相同，将指针指向的节点是节点之后的长度相同。<br>接着在两个链表的节点不同的情况下，对两个链表进行遍历，直到指针指向的值相同，输出这个相同时的节点。</p>
<pre><code class="Java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    int lengthA = 0;
    int lengthB = 0;
    ListNode nodeA = headA;
    ListNode nodeB = headB;
    while(nodeA != null){
        lengthA++;
        nodeA = nodeA.next;
    }
    while(nodeB!=null){
        lengthB++;
        nodeB = nodeB.next;
    }
    nodeA = headA;
    nodeB = headB;
    if(lengthA&gt;lengthB){
        int d = lengthA - lengthB;
        for(int i =0;i&lt;d&amp;&amp;nodeA!=null;i++){
            nodeA = nodeA.next
        }
    }else{
        int d = lengthB - lengthA;
        for(int i=0;i&lt;d&amp;&amp;nodeB!=null;i++){
            nodeB = nodeB.next;
        }
    }
    while(nodeA!=null&amp;&amp;nodeB!=null&amp;&amp;nodeA!=nodeB){
        nodeA = nodeA.next;
        nodeB = nodeB.next;
    }return nodeA; 
    }
}

</code></pre>
<h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a>203. 移除链表元素</h2><p>删除链表中等于给定值 <strong>val</strong> 的所有节点。</p>
<p><strong>示例:</strong></p>
<pre><code>输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6
输出: 1-&gt;2-&gt;3-&gt;4-&gt;5
</code></pre><pre><code class="java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        //在链表头添加一个结点，对链表进遍历和删除操作。一般貌似都是这样写的
        ListNode res = new ListNode(-1);
        res.next = head;
        //新建一个前驱节点，方便之后使用
        //因为删除时需要删除的节点前一个节点的位置
        ListNode prev = res;
        while(prev.next!=null){
            if(prev.next.val != val){
                prev = prev.next;
            }else{
                prev.next = prev.next.next;
            }
        }
        return res.next;
    }
}
</code></pre>
<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h2><p>思路就是当表的长度为1，直接返回；</p>
<p>不为一时，利用反转list，递归调用本方法，输出。</p>
<pre><code class="java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head==null||head.next==null){
            return head;
        }
        ListNode p = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        return p;
    }
}
</code></pre>
<p>另外一种方法：</p>
<pre><code class="java">class Solution{
    public ListNode reverseList(ListNode head){
        if(head==null||head.next==null){
            return head;
        }
        ListNode pre = head;
        ListNode pNode = head.next;
        ListNode next = head;
        pre.next = null;
        while(pNode != null){
            next = pNode.next;
            pNode.next = pre;
            pre = pNode;
            pNode = next;
        }
        return pre;
    }
}
</code></pre>
<p>这种方法用循环，遍历链表，新建前位链表、next 保存pNode的下一个，接着建立pNode的下一个就是pre，这样就完成了反转，然后向下计算，因为pNode和next之间的链接已经消去（因为指向了pre），next 用来记住原始链表的方向，这样开始循环，直到最后位null时结束循环。</p>
<h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a>234. 回文链表</h2><p>请判断一个链表是否为回文链表。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: 1-&gt;2
输出: false
</code></pre><p><strong>示例 2:</strong></p>
<pre><code>输入: 1-&gt;2-&gt;2-&gt;1
输出: true
</code></pre><p><strong>进阶：</strong><br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<pre><code class="java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        if(head==null||head.next==null){
            return true;
        }
        int len =0;
        ListNode fir = head;
        while(fir!= null){
            len++;
            fir = fir.next;
        }
        //将链表一分为二，前后一个一个进行比较
        int half = len/2;
        fir = head;
        //找到中间节点
        for(int i=0;i&lt;half;i++){
            fir = fir.next;
        }
        //这个是对后半链表进行翻转链表的操作
        ListNode pre = fir;
        ListNode pNode = fir.next;
        ListNode next = pNode;
        while(pNode!=null){
            next = pNode.next;
            pNode.next = pre;
            pre = pNode;
            pNode = next;
        }
        //接着相当于比较两个链表
        for(int i=0;i&lt;half;i++){
            if(head.val!=pre.val){
                return false;
            }
            head = head.next;
            pre = pre.next;
        }
        return true;
    }
}
</code></pre>
<h2 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="237. 删除链表中的节点"></a>237. 删除链表中的节点</h2><p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。</p>
<p>现有一个链表 – head = [4,5,1,9]，它可以表示为:</p>
<pre><code>    4 -&gt; 5 -&gt; 1 -&gt; 9
</code></pre><p><strong>示例 1:</strong></p>
<pre><code>输入: head = [4,5,1,9], node = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.
</code></pre><p><strong>示例 2:</strong></p>
<pre><code>输入: head = [4,5,1,9], node = 1
输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.
</code></pre><pre><code class="java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public void deleteNode(ListNode node) {
    int val = node.next.val;
    node.val = val;
    ListNode temp = node.next;
    node.next = temp.next;
    }
}
</code></pre>
<pre><code class="python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def deleteNode(self, node):
        &quot;&quot;&quot;
        :type node: ListNode
        :rtype: void Do not return anything, modify node in-place instead.
        &quot;&quot;&quot;
        node.val = node.next.val
        node.next = node.next.next
</code></pre>
<h2 id="347-前K个高频元素"><a href="#347-前K个高频元素" class="headerlink" title="347. 前K个高频元素#*"></a>347. 前K个高频元素#*</h2><p>给定一个非空的整数数组，返回其中出现频率前 <strong>k</strong> 高的元素。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
</code></pre><p><strong>示例 2:</strong></p>
<pre><code>输入: nums = [1], k = 1
输出: [1]
</code></pre><p><strong>说明：</strong></p>
<ul>
<li>你可以假设给定的 <em>k</em> 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</li>
<li>你的算法的时间复杂度<strong>必须</strong>优于 O(<em>n</em> log <em>n</em>) , <em>n</em> 是数组的大小。</li>
</ul>
<pre><code class="java">class Solution {
    public List&lt;Integer&gt; topKFrequent(int[] nums, int k) {
        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();

        PriorityQueue&lt;Map.Entry&lt;Integer,Integer&gt;&gt; pq = new PriorityQueue&lt;&gt;(new Comparator&lt;Map.Entry&lt;Integer, Integer&gt;&gt;() {
            @Override
            public int compare(Map.Entry&lt;Integer, Integer&gt; o1, Map.Entry&lt;Integer, Integer&gt; o2) {
                return o2.getValue()-o1.getValue();
            }
        });

        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();

        for (int i = 0; i &lt; nums.length; i++) 
            if (map.containsKey(nums[i]))
                map.put(nums[i],map.get(nums[i])+1);
            else
                map.put(nums[i],1);

        Set&lt;Map.Entry&lt;Integer,Integer&gt;&gt; set = map.entrySet();

        for (Map.Entry&lt;Integer,Integer&gt; entry : set)
            pq.add(entry);


        for (int i = 0; i &lt; k; i++) 
            list.add(pq.poll().getKey());

        return list;
    }
}
</code></pre>
<h2 id="442-数组中重复的数据"><a href="#442-数组中重复的数据" class="headerlink" title="442.数组中重复的数据"></a>442.数组中重复的数据</h2><p>给定一个整数数组 a，其中1 ≤ a[i] ≤ <em>n</em> （<em>n</em>为数组长度）, 其中有些元素出现<strong>两次</strong>而其他元素出现<strong>一次</strong>。</p>
<p>找到所有出现<strong>两次</strong>的元素。</p>
<p>你可以不用到任何额外空间并在O(<em>n</em>)时间复杂度内解决这个问题吗？</p>
<p><strong>示例：</strong></p>
<pre><code>输入:
[4,3,2,7,8,2,3,1]

输出:
[2,3]
</code></pre><p><strong>解决方法：</strong> 统计数组，找出出现第二次的元素的位置。i.e.，将数组的值当做序号建立新的数组，如果有重复的，新的数组的值会不是1，那么这个就是那个重复的元素。</p>
<pre><code class="java">class Solution {
    public List&lt;Integer&gt; findDuplicates(int[] nums) {
        int n = nums.length;
        int[] array = new int[n+1];
        List&lt;Integer&gt;res= new ArrayList&lt;&gt;();
        for(int i=0;i&lt;n;i++){
            array[nums[i]]+=1;
        }
        for(int i=0;i&lt;array.length;i++){
            if(array[i]&gt;1){
                res.add(i);
            }
        }
        return res;
    }
}
</code></pre>
<h2 id="717-1比特与2比特字符"><a href="#717-1比特与2比特字符" class="headerlink" title="717. 1比特与2比特字符"></a>717. 1比特与2比特字符</h2><p>有两种特殊字符。第一种字符可以用一比特<code>0</code>来表示。第二种字符可以用两比特(<code>10</code> 或 <code>11</code>)来表示。</p>
<p>现给一个由若干比特组成的字符串。问最后一个字符是否必定为一个一比特字符。给定的字符串总是由0结束。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: 
bits = [1, 0, 0]
输出: True
解释: 
唯一的编码方式是一个两比特字符和一个一比特字符。所以最后一个字符是一比特字符。
</code></pre><p><strong>示例 2:</strong></p>
<pre><code>输入: 
bits = [1, 1, 1, 0]
输出: False
解释: 
唯一的编码方式是两比特字符和两比特字符。所以最后一个字符不是一比特字符。
</code></pre><pre><code class="java">class Solution {
    public boolean isOneBitCharacter(int[] bits) {
        int i =0;
        while(i&lt;bits.length){
            if(i==bits.length-1){
                return true;
            }else if(bits[i]==0){
                i++;
            }else{
                i+=2;
            }
        }
        return false;
    }
}
</code></pre>
<pre><code class="python">class Solution:
    def isOneBitCharacter(self, bits):
        &quot;&quot;&quot;
        :type bits: List[int]
        :rtype: bool
        &quot;&quot;&quot;

        i = 0
        while (i&lt;len(bits)):
            if(i == len(bits)-1):
                return True
            elif(bits[i]==0):
                i+=1
            else:
                i+=2
        return False
</code></pre>
<h2 id="905-按奇偶排序数组"><a href="#905-按奇偶排序数组" class="headerlink" title="905. 按奇偶排序数组"></a>905. 按奇偶排序数组</h2><p>给定一个非负整数数组 <code>A</code>，返回一个由 <code>A</code> 的所有偶数元素组成的数组，后面跟 <code>A</code> 的所有奇数元素。</p>
<p>你可以返回满足此条件的任何数组作为答案。</p>
<p><strong>示例：</strong></p>
<pre><code>输入：[3,1,2,4]
输出：[2,4,3,1]
输出 [4,2,3,1]，[2,4,1,3] 和 [4,2,1,3] 也会被接受。
</code></pre><p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= A.length &lt;= 5000</code></li>
<li><code>0 &lt;= A[i] &lt;= 5000</code></li>
</ol>
<pre><code class="java">// 不使用额外的空间
class Solution {
    public int[] sortArrayByParity(int[] A) {
        int i = 0;
        int j = A.length-1;
        while(i&lt;j){
            if(A[i]%2!=0&amp;&amp;A[j]%2==0){
                int temp = A[i];
                A[i]=A[j];
                A[j]=temp;
                i++;
                j--;
            }else if(A[i]%2==0){
                i++;
            }else if(A[j]%2!=0){
                j--;
            }
        }
        return A;
    }
}
</code></pre>
<pre><code class="java">//使用额外空间
class Solution {
    public int[] sortArrayByParity(int[] A) {
        int[] B = new int[A.length];
        int j =0;
        int len = A.length-1;
        if(A.length == 1){return A;}
        while(j&lt;len){
            for(int i=0;i&lt;A.length;i++){
                if(A[i]%2==0){
                    B[j] = A[i];
                    j++;   
                }else{
                    B[len] = A[i];
                    len--;
                }
            }
        }
        return B;
    }
}
</code></pre>
<h2 id="914-卡牌分组"><a href="#914-卡牌分组" class="headerlink" title="914. 卡牌分组"></a>914. 卡牌分组</h2><p>给定一副牌，每张牌上都写着一个整数。</p>
<p>此时，你需要选定一个数字 <code>X</code>，使我们可以将整副牌按下述规则分成 1 组或更多组：</p>
<ul>
<li>每组都有 <code>X</code> 张牌。</li>
<li>组内所有的牌上都写着相同的整数。</li>
</ul>
<p>仅当你可选的 <code>X &gt;= 2</code> 时返回 <code>true</code>。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：[1,2,3,4,4,3,2,1]
输出：true
解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]
</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：[1,1,1,2,2,2,3,3]
输出：false
解释：没有满足要求的分组。
</code></pre><p><strong>示例 3：</strong></p>
<pre><code>输入：[1]
输出：false
解释：没有满足要求的分组。
</code></pre><p><strong>示例 4：</strong></p>
<pre><code>输入：[1,1]
输出：true
解释：可行的分组是 [1,1]
</code></pre><p><strong>示例 5：</strong></p>
<pre><code>输入：[1,1,2,2,2,2]
输出：true
解释：可行的分组是 [1,1]，[2,2]，[2,2]
</code></pre><p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= deck.length &lt;= 10000</code></li>
<li><code>0 &lt;= deck[i] &lt; 10000</code></li>
</ol>
<pre><code class="java">//使用Map来统计每张牌上数字出现的次数，求所有出现次数的最大公约数，如果最大公约数大于等于2，则返回 true
class Solution {
    public boolean hasGroupsSizeX(int[] deck) {
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer,Integer&gt;();
        for(int i:deck){
            map.put(i, map.getOrDefault(i,0)+1);
        }
        int minSize = Integer.MAX_VALUE;
        for(int i:map.values()){
            minSize = Math.min(minSize,i);
        }
        int i = 2;
        boolean res = false;
        while(i&lt;=minSize&amp;&amp;!res){
            boolean sign =  true;
            for(int x: map.values()){
                if(x%i!=0){
                sign = false;
                break;
                }
            }
            if(sign){
                return true;
            }
            i++;
        }
        return false;
    }
}
//辗转相除法求最大公约数
class Solution {
    public boolean hasGroupsSizeX(int[] deck) {
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();
        for(int i : deck) map.put(i, map.getOrDefault(i,0)+1);
        int minSize = Integer.MAX_VALUE;
        for(int i : map.values()) minSize = Math.min(minSize, i);
        int res = 0;
        for(int x : map.values()) res = mcd(x, res);
        return res &gt; 1;
    }
    public int mcd(int a, int b) {
        if (b &gt; a) {
            return mcd(b, a);
        }
        return b &gt; 0 ? mcd(b, a % b) : a;
    }
}
</code></pre>

      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="http://yoursite.com">Xu Jianxiang</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="http://yoursite.com/2019/02/20/Leetcode/">http://yoursite.com/2019/02/20/Leetcode/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span>
      
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/Leetcode/">Leetcode</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2019/02/21/Vuex/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Vuex的使用步骤</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2019/02/19/Vue-router有哪些钩子？使用场景？/">
        <span class="next-text nav-default">Vue-router有哪些钩子？使用场景？</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:xjxtju@163.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/Alfxjx" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    

    
      
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>



<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2018 - 
    
    2019

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Xu Jianxiang</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  

  



    
  



  
  





  
    <script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  

  
    <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.10.2"></script>

  </body>
</html>
